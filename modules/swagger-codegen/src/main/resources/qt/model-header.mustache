{{#models}}{{#model}}#ifndef AK_SWAGGER_{{classname}}_H_
#define AK_SWAGGER_{{classname}}_H_
{{/model}}
{{/models}}

#include "SwaggerUtils.h"
#include <QStringList> //fixme

class QJsonObject;

{{#imports}}{{{import}}}
{{/imports}}

{{#models}}{{#model}}
namespace swagger {

class {{classname}} {
    {{#hasEnums}}Q_GADGET{{/hasEnums}}
public:
    {{#vars}}{{#isEnum}}
    enum class {{innerDatatypeWithEnum}} {
        {{#allowableValues}}{{#values}} {{.}},
        {{/values}}{{/allowableValues}}
    };
    Q_ENUMS({{innerDatatypeWithEnum}});{{/isEnum}}{{/vars}}

    {{#hasRequiredVars}}{{classname}}();{{/hasRequiredVars}}
    {{classname}}({{#vars}}const {{{datatypeWithEnum}}} & {{name}}{{^required}} = {}{{/required}}{{#hasMore}},
        {{/hasMore}}{{/vars}});

    {{#vars}}
    {{{datatypeWithEnum}}} {{getter}}() const;
    void {{setter}}(const {{{datatypeWithEnum}}} & {{name}});

{{/vars}}

    QJsonObject serialize() const;
    static boost::optional<{{classname}}> unserialize(const QJsonObject & json);

private:
{{#vars}}    {{{datatypeWithEnum}}} m_{{name}};
{{/vars}}
};


SWAGGER_DECLARE_MODEL({{classname}});
{{#vars}}{{#isEnum}}
SWAGGER_DECLARE_ENUM({{classname}}, {{innerDatatypeWithEnum}});
{{/isEnum}}{{/vars}}
}

Q_DECLARE_METATYPE(swagger::{{classname}});

#endif
{{/model}}
{{/models}}
