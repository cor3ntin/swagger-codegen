#ifndef AK_SWAGGER_{{classname}}_H_
#define AK_SWAGGER_{{classname}}_H_

{{#imports}}{{{import}}}
{{/imports}}
#include <type_traits>
#include "AbstractRequest.h"
#include "ApiInvoker.h"
#include "SwaggerUtils.h"

class QNetworkReply;

namespace swagger {

{{#operations}}
namespace {{classname}} {

namespace responses {

{{#operation}}
    class {{nickname}}Request;
{{/operation}}
}
{{/operations}}

namespace operations {
{{#operations}}
{{#operation}}
{{#authMethods}}
//Requires authentification with scheme {{name}} ({{type}})
{{/authMethods}}
responses::{{nickname}}Request* {{nickname}}(AbstractApiInvoker* invoker{{#hasParams}},
                {{/hasParams}}{{#allParams}}{{^isFile}}{{^required}}boost::optional<{{{dataType}}}>{{/required}}{{#required}}{{^isPrimitiveType}}const {{/isPrimitiveType}}{{{dataType}}}{{^isPrimitiveType}}&{{/isPrimitiveType}}{{/required}}{{/isFile}}{{#isFile}}{{{dataType}}}{{/isFile}} {{paramName}}{{^required}} = {} {{/required}}{{#hasMore}},
                {{/hasMore}}{{/allParams}});

{{/operation}}
}


{{#operations}}
namespace responses {
{{#operation}}
namespace {{nickname}}RequestDetails {
    template  <typename T>
    struct ResponseInfo {};
    {{#responses}}
    {{#dataType}}
    template  <>
    struct ResponseInfo<{{{dataType}}}> {
        enum { code = {{code}} };
        using isDefault = std::integral_constant<bool, {{code}} == 0>;
        using isSuccess = std::integral_constant<bool, ({{code}} >= 200 && {{code}} < 400)>;
    };{{/dataType}}{{^dataType}}
    template  <>
    struct ResponseInfo<void> {
        enum { code = {{code}} };
        using isDefault = std::integral_constant<bool, {{code}} == 0>;
        using isSuccess = std::integral_constant<bool, ({{code}} >= 200 && {{code}} < 400)>;
    };{{/dataType}}
    {{/responses}}
    namespace details {
        template <typename... Args> struct Count;
        template <>
        struct Count<> {
            using success  = std::integral_constant<int, 0>;
            using failure  = std::integral_constant<int, 0>;
        };

        template <typename A1>
        struct Count<A1> {
            using success  = typename std::integral_constant<int, ((ResponseInfo<A1>::isSuccess::value && !ResponseInfo<A1>::isDefault::value) ? 1 : 0)>;
            using failure  = typename std::integral_constant<int, ((!ResponseInfo<A1>::isSuccess::value && !ResponseInfo<A1>::isDefault::value) ? 1 : 0)>;
        };

        template <typename A1, typename A2, typename... Args>
        struct Count<A1, A2, Args...> {
            using success  = std::integral_constant<int, Count<Args...>::success::value
                + Count<A1>::success::value + Count<A2>::success::value  >;
            using failure  = typename std::integral_constant<int, Count<Args...>::failure::value
                + Count<A1>::failure::value + Count<A2>::failure::value  >;
        };
        template <typename... Args>
        struct Arities {
            enum  {
                total = sizeof...(Args),
                success = Count<Args...>::success::value,
                error = Count<Args...>::failure::value,
            };
            using hasDefault = std::integral_constant<bool, total != success+error>;

        };
    }
    using Arities = details::Arities<{{#responses}}{{#dataType}}{{{dataType}}}{{/dataType}}{{^dataType}}void{{/dataType}}{{#hasMore}},{{/hasMore}}{{/responses}}>;
}
{{/operation}}

{{#operation}}
class {{nickname}}Request : public AbstractRequest {
    Q_OBJECT
public:
    {{nickname}}Request(AbstractApiInvoker::RequestParams && params, AbstractApiInvoker* invoker, QStringList && authSchemes);

Q_SIGNALS:
{{#responses}}
    void finished{{code}}({{#dataType}}{{{dataType}}}{{/dataType}});
{{/responses}}

public:
{{#responses}}
    SWAGGER_SMART_SLOT({{nickname}},{{#dataType}}{{{dataType}}}{{/dataType}}{{^dataType}}void{{/dataType}}, {{code}})
{{/responses}}
    template <typename... Args>
    {{nickname}}Request* then(Args... args) {
        connect(this, &AbstractRequest::done, std::forward<Args>(args)...);
        return this;
    }
    template <typename... Args>
    {{nickname}}Request* onUnexpectedError(Args... args) {
        connect(this, &AbstractRequest::failed, std::forward<Args>(args)...);
        return this;
    }
protected:
    AbstractRequest::Error processResponse(int status, const QJsonValue & data);

private:
};

{{/operation}}
} //namespace responses
{{/operations}}

} //namespace {{classname}}
{{/operations}}

} //namespace swagger

#endif /* {{classname}}_H_ */