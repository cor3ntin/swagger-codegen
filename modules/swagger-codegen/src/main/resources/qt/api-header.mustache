#ifndef AK_SWAGGER_{{classname}}_H_
#define AK_SWAGGER_{{classname}}_H_

{{#imports}}{{{import}}}
{{/imports}}
#include <type_traits>
#include "AbstractRequest.h"
#include "ApiInvoker.h"
#include "SwaggerUtils.h"

class QNetworkReply;

namespace swagger {

{{#operations}}
namespace {{classname}} {

namespace responses {

{{#operation}}
    class {{operationId}}Request;
{{/operation}}
}
{{/operations}}

namespace operations {
{{#operations}}
{{#operation}}
{{#authMethods}}
//Requires authentification with scheme {{name}} ({{type}})
{{/authMethods}}
Sender<responses::{{operationId}}Request> {{operationId}}(AbstractApiInvoker* invoker{{#hasParams}},
                {{/hasParams}}{{#allParams}}{{^isFile}}{{^required}}boost::optional<{{{dataType}}}>{{/required}}{{#required}}{{^isPrimitiveType}}const {{/isPrimitiveType}}{{{dataType}}}{{^isPrimitiveType}}&{{/isPrimitiveType}}{{/required}}{{/isFile}}{{#isFile}}{{{dataType}}}{{/isFile}} {{paramName}}{{^required}} = {} {{/required}}{{#hasMore}},
                {{/hasMore}}{{/allParams}});

{{/operation}}
}


{{#operations}}
namespace responses {

{{#operation}}
class {{operationId}}Request : public AbstractRequest {
    Q_OBJECT
public:
    {{operationId}}Request(AbstractApiInvoker::RequestParams && params, AbstractApiInvoker* invoker, QStringList && authSchemes);
    {{operationId}}Request* setRawHeader(const QByteArray & k, const QByteArray & v) {
        AbstractRequest::setRawHeader(k, v);
        return this;
    }

Q_SIGNALS:
{{#responses}}
    void finished{{code}}({{#dataType}}{{{dataType}}}{{/dataType}});
{{/responses}}

public:
{{#responses}}
    {{#isUnique}}SWAGGER_SMART_SLOT({{operationId}},{{#dataType}}{{{dataType}}}{{/dataType}}{{^dataType}}void{{/dataType}}, {{code}}, onFinished){{/isUnique}}
    {{#isUniqueSuccess}}SWAGGER_SMART_SLOT({{operationId}},{{#dataType}}{{{dataType}}}{{/dataType}}{{^dataType}}void{{/dataType}}, {{code}}, onSuccess){{/isUniqueSuccess}}
    {{#isUniqueError}}SWAGGER_SMART_SLOT({{operationId}},{{#dataType}}{{{dataType}}}{{/dataType}}{{^dataType}}void{{/dataType}}, {{code}}, onError){{/isUniqueError}}
    {{^isUnique}}SWAGGER_SMART_SLOT({{operationId}},{{#dataType}}{{{dataType}}}{{/dataType}}{{^dataType}}void{{/dataType}}, {{code}}, on{{code}}){{/isUnique}}
{{/responses}}
    template <typename... Args>
    {{operationId}}Request* then(Args... args) {
        connect(this, &AbstractRequest::done, std::forward<Args>(args)...);
        return this;
    }
    template <typename... Args>
    {{operationId}}Request* onUnexpectedError(Args... args) {
        connect(this, &AbstractRequest::failed, std::forward<Args>(args)...);
        return this;
    }
protected:
    AbstractRequest::Error processResponse(int status, const QJsonValue & data);

private:
};

{{/operation}}
} //namespace responses
{{/operations}}

} //namespace {{classname}}

#ifdef QT_QML_LIB
class {{classname}}_QML : public QObject {
    Q_OBJECT
protected:
    Q_INVOKABLE {{classname}}_QML() = default;
public:
    Q_INVOKABLE {{classname}}_QML(AbstractApiInvoker* invoker)
        : m_invoker(invoker) {}
{{#operations}}
        {{#operation}}
        Q_INVOKABLE QObject* {{operationId}}({{#allParams}}{{^isFile}} const QVariant{{#isContainer}}List{{/isContainer}} & {{paramName}}{{/isFile}}{{#hasMore}},
        {{/hasMore}}{{/allParams}});
        {{/operation}}
{{/operations}}
private:
    AbstractApiInvoker* m_invoker = nullptr;
};
#endif
{{/operations}}


} //namespace swagger

#endif /* {{classname}}_H_ */