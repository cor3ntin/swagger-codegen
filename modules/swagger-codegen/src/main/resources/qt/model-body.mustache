{{#models}}
{{#model}}
#include "{{classname}}.h"
#include <QJsonObject>
{{#hasEnums}}#include <QMetaEnum>{{/hasEnums}}

namespace swagger {

{{#vars}}{{#isEnum}}
SWAGGER_REGISTER_ENUM({{classname}}, {{innerDatatypeWithEnum}});
{{/isEnum}}{{/vars}}



{{#hasRequiredVars}}{{{classname}}}::{{{classname}}}()
{{#hasVars}}    : {{#vars}}m_{{name}}{}{{#hasMore}}
    , {{/hasMore}}{{/vars}} {{/hasVars}} {
}{{/hasRequiredVars}}

{{{classname}}}::{{{classname}}}({{#vars}}const {{{datatypeWithEnum}}} & {{name}}{{#hasMore}},
        {{/hasMore}}{{/vars}}) {

{{#vars}}    {{setter}}({{name}});
{{/vars}}
}


{{#vars}}
auto {{{classname}}}::{{getter}}() const -> {{{datatypeWithEnum}}} {
    return m_{{name}};
}

void  {{{classname}}}::{{setter}}(const {{{datatypeWithEnum}}} & {{name}}) {
    m_{{name}} = {{name}};
}

{{/vars}}


QJsonObject {{classname}}::serialize() const {
    QJsonObject json;

    {{#vars}}
    json.insert("{{name}}", swagger::serialize(m_{{name}}));
    {{/vars}}
    return json;
}

boost::optional<{{classname}}> {{classname}}::unserialize(const QJsonObject & json) {
    auto it = json.end();
    {{classname}} obj;{{#vars}}
    if((it = json.find("{{name}}")) != std::end(json)) {
        auto v = swagger::unserialize<{{{datatypeWithEnum}}}>(*it);
        {{#required}}if(!v) return {};
        {{/required}}{{^required}}if(v) {{/required}}obj.{{setter}}(*v);
    }{{#required}}
    else return {};{{/required}}{{/vars}}
    return obj;

}

#ifdef QT_QML_LIB
SWAGGER_REGISTER_QML_ENTITY({{classname}});
#endif 
} /* namespace Swagger */

{{/model}}
{{/models}}
