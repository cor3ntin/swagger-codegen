{{#models}}
{{#model}}
#include "{{classname}}.h"
#include <QJsonObject>
{{#hasEnums}}#include <QMetaEnum>{{/hasEnums}}

namespace swagger {

{{#hasRequiredVars}}{{{classname}}}::{{{classname}}}()
{{#hasVars}}    : {{#vars}}m_{{name}}{}{{#hasMore}}
    , {{/hasMore}}{{/vars}} {{/hasVars}} {
}{{/hasRequiredVars}}

{{{classname}}}::{{{classname}}}({{#vars}}{{^isEnum}}{{^isPrimitiveType}}const {{/isPrimitiveType}}{{{datatype}}}{{^isPrimitiveType}}&{{/isPrimitiveType}}{{/isEnum}}{{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}} {{name}}{{#hasMore}},
        {{/hasMore}}{{/vars}}) {

{{#vars}}    {{setter}}({{name}});
{{/vars}}
}


{{#vars}}
{{#isEnum}}{{{classname}}}::{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{datatype}}}{{/isEnum}} {{{classname}}}::{{getter}}() const {
    return m_{{name}};
}

void  {{{classname}}}::{{setter}}({{^isEnum}}{{^isPrimitiveType}}const {{/isPrimitiveType}}{{{datatype}}}{{^isPrimitiveType}}&{{/isPrimitiveType}}{{/isEnum}}{{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}} {{name}}) {
    m_{{name}} = {{name}};
}

{{/vars}}


QJsonObject {{classname}}::serialize() const {
    QJsonObject json;

    {{#vars}}
    {{#isEnum}}json.insert("{{name}}", SWAGGER_SERIALIZE_QENUM({{classname}}, {{{datatypeWithEnum}}}, m_{{name}}));{{/isEnum}}
    {{^isEnum}}json.insert("{{name}}", swagger::serialize(m_{{name}}));{{/isEnum}}
    {{/vars}}
    return json;
}

boost::optional<{{classname}}> {{classname}}::unserialize(const QJsonObject & json) {
    auto it = json.end();
    {{classname}} obj;{{#vars}}
    if((it = json.find("{{name}}")) != std::end(json)) {
        auto v = {{#isEnum}}SWAGGER_UNSERIALIZE_QENUM({{classname}}, {{{datatypeWithEnum}}}, *it){{/isEnum}}{{^isEnum}}swagger::unserialize<{{{datatype}}}>(*it){{/isEnum}};
        {{#required}}if(!v) return {};
        {{/required}}{{^required}}if(v) {{/required}}obj.{{setter}}(*v);
    }{{#required}}
    else return {};{{/required}}{{/vars}}
    return obj;
}

} /* namespace Swagger */

{{/model}}
{{/models}}
