#ifndef AK_SWAGGER_{{classname}}_H_
#define AK_SWAGGER_{{classname}}_H_

{{#imports}}{{{import}}}
{{/imports}}
#include "AbstractResponse.h"
#include "ApiInvoker.h"

class QNetworkReply;

namespace swagger {

template <typename T>
using Optional = boost::optional<T>;

{{#operations}}
namespace {{classname}} {

namespace responses {

{{#operation}}
    class {{nickname}}Response;
{{/operation}}
}
{{/operations}}


{{#operations}}
{{#operation}}
responses::{{nickname}}Response* {{nickname}}(AbstractApiInvoker* invoker{{#hasParams}},
                {{/hasParams}}{{#allParams}}{{^isFile}}{{^required}}Optional<{{{dataType}}}>{{/required}}{{#required}}{{^isPrimitiveType}}const {{/isPrimitiveType}}{{{dataType}}}{{^isPrimitiveType}}&{{/isPrimitiveType}}{{/required}}{{/isFile}}{{#isFile}}{{{dataType}}}{{/isFile}} {{paramName}}{{^required}} = {} {{/required}}{{#hasMore}},
                {{/hasMore}}{{/allParams}});

{{/operation}}


{{#operations}}
namespace responses {

{{#operation}}
class {{nickname}}Response : public AbstractResponse {

public:
    {{nickname}}Response(QNetworkReply* reply, AbstractApiInvoker* invoker);
    {{nickname}}Response* onEmptyResponse(std::function<void(int)>);
{{#responses}}{{#dataType}}    {{nickname}}Response* on(const std::function<void({{{dataType}}})> & callback);{{/dataType}}
{{/responses}}

protected:
    bool processResponse(int status, const QJsonValue & data);

private:
{{#responses}}{{#dataType}}    std::function<void({{{dataType}}})> m_{{code}}_fun;{{/dataType}}
{{/responses}}
};

{{/operation}}
} //namespace responses
{{/operations}}

} //namespace {{classname}}
{{/operations}}

} //namespace swagger

#endif /* {{classname}}_H_ */